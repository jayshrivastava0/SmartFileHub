from django.db import models
from django.db.models import Sum, Count, F
import uuid
import os

def file_upload_path(instance, filename):
    """
    Generate a unique file path for a new file upload.
    
    This function creates a path in the format 'uploads/<uuid>.<ext>'
    to prevent filename collisions and obscure original filenames on the server.

    Args:
        instance: The File model instance being saved.
        filename (str): The original filename of the uploaded file.

    Returns:
        str: The generated unique file path.
    """
    # Get the file extension from the original filename.
    ext = filename.split('.')[-1]
    # Create a new unique filename using UUID4.
    filename = f"{uuid.uuid4()}.{ext}"
    # Return the full path relative to the MEDIA_ROOT.
    return os.path.join('uploads', filename)

class File(models.Model):
    """
    Represents a file entry in the database.
    
    This model stores metadata about each uploaded file, including a reference
    to the original file in case of a duplicate, to support deduplication.
    """
    # A unique UUID primary key for each file record.
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    
    # The actual file stored on the filesystem. Uploaded to the path generated by file_upload_path.
    file = models.FileField(upload_to=file_upload_path)
    
    # The original filename as provided by the user. Indexed for fast searching.
    original_filename = models.CharField(max_length=255, db_index=True)
    
    # The MIME type of the file (e.g., 'image/jpeg').
    file_type = models.CharField(max_length=100)
    
    # The size of the file in bytes. Indexed for fast filtering by size.
    size = models.BigIntegerField(db_index=True)
    
    # The timestamp when the file was uploaded. Indexed for fast filtering by date.
    uploaded_at = models.DateTimeField(auto_now_add=True, db_index=True)
    
    # A self-referential foreign key to handle deduplication.
    # If this file is a duplicate, this field points to the original File instance.
    # If it's an original file, this field is NULL.
    original_file = models.ForeignKey('self', null=True, blank=True, on_delete=models.SET_NULL, related_name='duplicates')
    
    class Meta:
        # Default ordering for queries, showing the most recent files first.
        ordering = ['-uploaded_at']
        
        # Database indexes to optimize query performance for common filter operations.
        indexes = [
            models.Index(fields=['file_type', 'size']),
            models.Index(fields=['size', 'uploaded_at']),
            models.Index(fields=['file']),
        ]
    
    def __str__(self):
        """String representation of the File model, used in Django admin."""
        return self.original_filename

def get_total_saving_size():
    """
    Calculates the total storage space saved due to file deduplication.

    It finds all file entries that are duplicates, sums up their sizes,
    and formats the result into a human-readable format (B, KB, MB, GB).

    Returns:
        dict: A dictionary with the saved size and its unit, e.g., {'size': 15.3, 'unit': 'MB'}.
    """
    # Identify file groups that share the same physical file path and have more than one entry.
    # This signifies that one is original and the others are duplicates.
    duplicate_files = (
        File.objects.values('file', 'size')
        .annotate(count=Count('id'))
        .filter(count__gt=1)
    )

    # Calculate the total saved size in bytes.
    # For each group of duplicates, the saving is (size * (count - 1)).
    total_saving_bytes = duplicate_files.aggregate(
        total_saving=Sum(F('size') * (F('count') - 1))
    )['total_saving']
    
    # If there are no savings, return 0.
    if not total_saving_bytes:
        return {'size': 0, 'unit': 'bytes'}
        
    # Convert the total bytes into a more readable unit (KB, MB, GB).
    if total_saving_bytes < 1024:
        return {'size': total_saving_bytes, 'unit': 'bytes'}
    elif total_saving_bytes < 1024**2:
        return {'size': round(total_saving_bytes / 1024, 2), 'unit': 'KB'}
    elif total_saving_bytes < 1024**3:
        return {'size': round(total_saving_bytes / (1024**2), 2), 'unit': 'MB'}
    else:
        return {'size': round(total_saving_bytes / (1024**3), 2), 'unit': 'GB'}